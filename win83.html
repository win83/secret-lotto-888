<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>æˆ°å ´ç›£æ§ Pro - å…¨èƒ½å›æ¸¬ç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        :root { --defense: #2c3e50; --win: #d93025; --bg: #f8f9fa; --ready: #fff9c4; --dist: #607d8b; --rank: #546e7a; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 2px; background: var(--bg); font-size: 10px; overflow-x: hidden; color: #000; }
        
        .container { width: 100%; height: 100vh; display: flex; flex-direction: column; background: white; }
        
        /* å·¥å…·åˆ— */
        .btn-group { padding: 5px; background: #eee; display: flex; gap: 8px; align-items: center; border-bottom: 1px solid #ddd; flex-wrap: wrap; z-index: 9000; }
        .btn-game { padding: 4px 10px; border: none; border-radius: 3px; color: white; cursor: pointer; font-weight: bold; }
        .btn-mode { padding: 4px 12px; border: 1px solid #999; border-radius: 3px; background: white; cursor: pointer; font-weight: bold; color: #000; transition: all 0.2s; }
        .btn-mode.active { background: #007bff; color: white; border-color: #0056b3; }
        .btn-report { background: #673ab7; color: white; border: none; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-weight: bold; }
        .btn-add-report { background: #28a745; color: white; border: none; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-weight: bold; }
        
        .draw-tools { display: flex; align-items: center; gap: 5px; background: #f1f1f1; padding: 2px 10px; border-radius: 20px; border: 1px solid #ccc; margin-left: 5px; }
        .input-n { width: 45px; padding: 2px; font-size: 9px; text-align: center; border: 1px solid #ccc; border-radius: 3px; }

        /* è‡ªé©æ‡‰è¡¨æ ¼æ ¸å¿ƒ */
        .table-wrapper { width: 100%; overflow-x: hidden; overflow-y: auto; flex: 1; position: relative; scroll-behavior: smooth; background: #fff; }
        table { border-collapse: separate; border-spacing: 0; table-layout: fixed; width: 100%; min-width: 100%; }
        th, td { border: 1px solid #ddd; text-align: center; padding: 4px 0; background-color: white; color: #000; box-sizing: border-box; overflow: hidden; white-space: nowrap; }
        
        /* å›ºå®šå·¦å´ 85px */
        .sticky-col { 
            width: 85px; min-width: 85px; 
            position: sticky; left: 0; 
            z-index: 2000; 
            background-color: #eceff1 !important; 
            border-right: 2px solid #bbb !important; 
            font-weight: bold;
        }

        .recent-header { position: sticky; z-index: 4001; }
        .sticky-header { position: sticky; z-index: 4002; }
        .second-header { position: sticky; z-index: 4000; }
        
        .recent-header .sticky-col, 
        .sticky-header .sticky-col, 
        .second-header .sticky-col { z-index: 5000; background-color: #cfd8dc !important; }

        .ready-line td, .ready-line th { background-color: var(--ready) !important; cursor: pointer; }
        .second-header th { background-color: var(--defense) !important; color: white; }

        /* ç›£æ§æ¨¡å¼åˆ†çµ„è¦–è¦º */
        .group-row td:first-child { border-left: 4px solid #000 !important; }
        .group-row td:last-child { border-right: 4px solid #000 !important; }
        .group-first-row td { border-top: 4px solid #000 !important; }
        .group-last-row td { border-bottom: 4px solid #000 !important; }
        
        .row-win-bg td { background-color: #fff1f0 !important; }
        .row-loss-bg td { background-color: #f6ffed !important; }
        .row-dist-bg td { background-color: #f0f4f8 !important; }

        .col-active { background-color: #bae7ff !important; border-left: 1px solid #007bff !important; border-right: 1px solid #007bff !important; z-index: 10; }
        td.top5-mark { background-color: #ffeb3b !important; font-weight: 900; border: 1.5px solid #000 !important; }
        td.rank-top5-mark { background-color: #52c41a !important; font-weight: 900; border: 1.5px solid #000 !important; }

        /* èµ°å‹¢åœ– */
        .chart-row td { height: 140px; padding: 0 !important; position: relative; }
        .chart-container-wrapper { width: 100%; height: 100%; background: #fff; position: relative; overflow: hidden; display: block; margin-left: 2px; }
        .chart-v-highlight { position: absolute; top: 0; width: calc(100% / var(--total-cols)); height: 100%; background: rgba(0, 123, 255, 0.15); border-left: 1px solid #007bff; border-right: 1px solid #007bff; z-index: 1; pointer-events: none; box-sizing: border-box; }
        .chart-legend { position: absolute; top: 5px; left: 10px; background: rgba(255,255,255,0.85); padding: 2px 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 8px; display: flex; gap: 8px; z-index: 10; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

        /* å£«å…µä½ç½®åœ–è·¯å¾‘ */
        #pathCanvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 45; width: 100%; height: 100%; }
        .soldier-win { background-color: #ff0000 !important; color: white !important; font-weight: bold; }
        .row-soldier { height: 26px; cursor: pointer; }
        .path-active { outline: 3px solid #007bff !important; outline-offset: -3px; background-color: #e6f7ff !important; }
        
        .ignored-row { opacity: 0.35; }
        .backtest-line { background-color: #fff9c4 !important; }

        /* å ±è¡¨ä»‹é¢ */
        #reportModal { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: white; z-index: 9999; flex-direction: column; }
        #reportHeader { padding: 10px 15px; background: #673ab7; color: white; display: flex; justify-content: space-between; align-items: center; }
        #reportContent { flex: 1; overflow: auto; padding: 15px; }
        .report-entry-card { border: 1px solid #ccc; border-radius: 6px; padding: 12px; margin-bottom: 15px; background: #fafafa; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .report-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 10px; }
        .report-table th, .report-table td { border: 1px solid #ccc; padding: 6px; text-align: center; }
        .report-table th { background: #f0f0f0; }
        .tag { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 9px; margin-right: 5px; color: white; font-weight: bold; }
        .hidden { display: none !important; }
    </style>
</head>
<body style="--total-cols: 39;">

<div class="container">
    <div class="btn-group">
        <button class="btn-game" onclick="init('539', 39)" style="background:#27ae60;">539</button>
        <button class="btn-game" onclick="init('49', 49)" style="background:#c0392b;">49</button>
        <div style="margin-left: 10px; display: flex; gap: 5px;">
            <button id="btnMonitor" class="btn-mode active" onclick="switchMode('monitor')">ç›£æ§æ¨¡å¼</button>
            <button id="btnSoldier" class="btn-mode" onclick="switchMode('soldier')">å£«å…µä½ç½®åœ–</button>
        </div>
        
        <div id="drawToolbar" class="draw-tools hidden">
            <span style="font-size: 9px; color: #666; font-weight: bold;">å›çœ‹:</span>
            <input type="number" id="nLimitInput" class="input-n" value="50" min="1" max="500" onchange="g_nLimit = parseInt(this.value); renderSoldierMode(); renderHeader();">
            <span style="font-size: 9px; color: #555; margin-left:10px;">é»é¸è™Ÿç¢¼ç”¢ç”Ÿè·¯å¾‘</span>
            <button class="btn-add-report" onclick="handleAddReport()" style="margin-left:10px;">åŠ å…¥å ±è¡¨ (Enter)</button>
        </div>

        <button class="btn-report" onclick="toggleReport(true)">åˆ†æå ±è¡¨</button>
    </div>

    <div class="table-wrapper" id="scrollArea">
        <svg id="pathCanvas" class="hidden"></svg>
        <table id="matrixTable">
            <thead id="mHead"></thead>
            <tbody id="mBodyMonitor"></tbody>
            <tbody id="mBodySoldier" class="hidden"></tbody>
        </table>
    </div>
</div>

<div id="reportModal">
    <div id="reportHeader">
        <strong style="font-size:14px;">å£«å…µä½ç½®è·é›¢é…å°åˆ†æå ±è¡¨</strong>
        <div style="display:flex; gap:8px;">
            <button onclick="g_analysisEntries=[]; renderReportTable();" style="background:#f44336; color:white; border:none; padding:5px 12px; border-radius:4px; cursor:pointer; font-weight:bold;">å…¨éƒ¨åˆªé™¤</button>
            <button onclick="toggleReport(false)" style="background:white; border:none; padding:5px 15px; cursor:pointer; border-radius:4px; font-weight:bold;">é—œé–‰è¦–çª—</button>
        </div>
    </div>
    <div id="reportContent">
        <div id="reportEmpty" style="text-align:center; padding:40px; color:#999;">
            <h3>å°šæœªæ“·å–ä»»ä½•ç‰¹å¾µç¾¤çµ„</h3>
            <p>è«‹åœ¨ã€Œå£«å…µä½ç½®åœ–ã€æ¨¡å¼ä¸‹ï¼Œé»é¸è™Ÿç¢¼é€£ç·šå¾ŒæŒ‰ ENTER æˆ–æŒ‰éˆ•åŠ å…¥ã€‚</p>
        </div>
        <div id="entriesArea"></div>
    </div>
</div>

<script>
    let g_max = 39, g_matrix = {}, g_curOrder = [], g_type = '539', g_raw_data = [];
    let g_mode = 'monitor', g_history = [], g_focusNum = null, g_focusPos = [], g_activePaths = new Map();
    let g_backtestIdx = -1, g_nLimit = 50, g_analysisEntries = [];

    window.onload = () => {
        init('539', 39);
        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Enter' && g_mode === 'soldier') handleAddReport();
        });
    };

    function init(type, max) {
        g_type = type; g_max = max; g_backtestIdx = -1; g_activePaths.clear(); g_analysisEntries = [];
        g_matrix = {}; 
        document.body.style.setProperty('--total-cols', max);
        Papa.parse(`https://raw.githubusercontent.com/win83/secret-lotto-888/main/fine/${type}-all.csv`, {
            download: true, header: true, skipEmptyLines: true,
            complete: (res) => { if(res.data) { g_raw_data = res.data; processData(res.data, max); } }
        });
    }

    function processData(data, max) {
        let tempOrder = Array.from({length: max}, (_, i) => i + 1);
        const bIdx = (max === 39) ? [2,3,4,5,6] : [2,3,4,5,6,7];
        const keys = Object.keys(data[0]);
        g_history = [];
        data.forEach(row => {
            let balls = bIdx.map(idx => parseInt(row[keys[idx]])).filter(v => !isNaN(v));
            if(balls.length < 5) return;
            g_history.push({ sn: row[keys[0]], order: [...tempOrder], balls: balls });
            let winB = tempOrder.filter(n => balls.includes(n));
            tempOrder = [...winB, ...tempOrder.filter(n => !balls.includes(n))];
        });
        g_curOrder = tempOrder;
        updateMatrix(); renderHeader(); renderMonitorMode(); renderSoldierMode();
    }

    function updateMatrix() {
        g_matrix = {}; for(let b=1; b<=g_max; b++) { g_matrix[b] = {}; for(let p=0; p<g_max; p++) g_matrix[b][p] = { win: 0, fail: 0 }; }
        let targetHistory = g_backtestIdx === -1 ? g_history : g_history.slice(0, g_backtestIdx + 1);
        targetHistory.forEach(item => { item.order.forEach((n, i) => { if(item.balls.includes(n)) g_matrix[n][i].win++; else g_matrix[n][i].fail++; }); });
    }

    function renderHeader() {
        if (!g_history || g_history.length === 0) return;
        let displayOrder = g_backtestIdx === -1 ? g_curOrder : g_history[g_backtestIdx].order;
        let headHtml = ""; let stickyTop = 0;
        if (g_mode === 'monitor') {
            let recent = g_history.slice(-5);
            recent.forEach((item, rIdx) => {
                headHtml += `<tr class="recent-header row-soldier" style="top: ${rIdx * 25}px;">
                                <td class="sticky-col">${item.sn}</td>
                                ${item.order.map((n, pIdx) => `<td class="${item.balls.includes(n) ? 'soldier-win' : ''}">${n}</td>`).join('')}
                             </tr>`;
            });
            stickyTop = recent.length * 25;
        }
        headHtml += `<tr class="sticky-header ready-line" style="top: ${stickyTop}px;">
                        <th class="sticky-col" onclick="setBacktest(-1)">æ¨æ¼”é»${g_backtestIdx===-1?'':'ğŸ”„'}</th>
                        ${displayOrder.map((n, idx) => `<th onclick="handleHeaderClick(${n}, ${idx})" data-ball="${n}">${n}</th>`).join('')}
                     </tr>
                     <tr class="second-header" style="top: ${stickyTop + 25}px;">
                        <th class="sticky-col">ä½ç½®</th>
                        ${Array.from({length:g_max},(_,i)=>`<th>P${i+1}</th>`).join('')}
                     </tr>`;
        document.getElementById('mHead').innerHTML = headHtml;
    }

    function handleHeaderClick(ballNum, posIdx) {
        if (g_mode === 'monitor') {
            const isSameNum = g_focusNum === ballNum;
            if (isSameNum && g_focusPos.includes(posIdx)) { g_focusNum = null; g_focusPos = []; } 
            else { g_focusNum = ballNum; g_focusPos = [posIdx]; }
            renderMonitorMode(); renderHeader();
            if (g_focusNum !== null) {
                setTimeout(() => {
                    const target = document.getElementById(`row-win-${ballNum}`);
                    const wrapper = document.getElementById('scrollArea');
                    const thead = document.querySelector('#matrixTable thead');
                    if (target && wrapper && thead) {
                        const targetTop = target.offsetTop - thead.offsetHeight - 5;
                        wrapper.scrollTo({ top: targetTop, behavior: 'smooth' });
                    }
                }, 100);
            }
        } else toggleBallPath(parseInt(ballNum));
    }

    function renderMonitorMode() {
        if (!g_matrix || Object.keys(g_matrix).length === 0) return;
        let bHtml = ""; 
        for(let b=1; b<=g_max; b++) {
            if (!g_matrix[b]) continue;
            let winData = [], failData = [], distData = [], rateData = [];
            for(let p=0; p<g_max; p++) {
                let w = g_matrix[b][p].win || 0, f = g_matrix[b][p].fail || 0;
                winData.push(w); failData.push(f); distData.push(f - w);
                rateData.push((w+f) > 0 ? Math.round((w / (w+f)) * 100) : 0);
            }
            const winT5 = getRowTop5(winData), winR = getRowRanks(winData), failBottom5 = getRowBottom5(failData);
            const failR = getRowRanks(failData), distBottom5 = getRowBottom5(distData), distRAsc = getRowRanksAsc(distData), rateT5 = getRowTop5(rateData);
            const activeCol = (p) => g_focusPos.includes(p) ? 'col-active' : '';

            bHtml += `<tr id="row-win-${b}" class="row-win row-win-bg group-first-row group-row">
                        <td class="sticky-col" onclick="g_focusNum=${b};renderMonitorMode()">#${b<10?'0'+b:b} è´å¤š</td>
                        ${winData.map((v, p) => `<td class="${activeCol(p)} ${winT5.includes(p)?'top5-mark':''}">${v||''}</td>`).join('')}
                      </tr>
                      <tr class="group-row row-win-bg">
                        <td class="sticky-col">è´æ’å1~39</td>
                        ${winR.map((v, p) => `<td class="${activeCol(p)} ${v<=5?'rank-top5-mark':''}">${v}</td>`).join('')}
                      </tr>
                      <tr class="group-row row-loss-bg">
                        <td class="sticky-col">è¼¸å°‘</td>
                        ${failData.map((v, p) => `<td class="${activeCol(p)} ${failBottom5.includes(p)?'top5-mark':''}">${v||''}</td>`).join('')}
                      </tr>
                      <tr class="group-row row-loss-bg">
                        <td class="sticky-col">è¼¸æ’å39~1</td>
                        ${failR.map((v, p) => `<td class="${activeCol(p)} ${v >= (g_max - 4) ? 'rank-top5-mark' : ''}">${v}</td>`).join('')}
                      </tr>
                      <tr class="group-row row-dist-bg">
                        <td class="sticky-col">è·é›¢å°‘-ã€‹å¤š</td>
                        ${distData.map((v, p) => `<td class="${activeCol(p)} ${distBottom5.includes(p)?'top5-mark':''}">${v}</td>`).join('')}
                      </tr>
                      <tr class="group-row row-dist-bg">
                        <td class="sticky-col">è·é›¢æ’åå°‘-ã€‹å¤š</td>
                        ${distRAsc.map((v, p) => `<td class="${activeCol(p)} ${v<=5?'rank-top5-mark':''}">${v}</td>`).join('')}
                      </tr>
                      <tr class="group-row">
                        <td class="sticky-col">å‹ç‡é«˜</td>
                        ${rateData.map((v, p) => `<td class="${activeCol(p)} ${rateT5.includes(p)?'top5-mark':''}">${v||''}</td>`).join('')}
                      </tr>
                      <tr class="chart-row group-last-row group-row">
                        <td class="sticky-col" style="font-size:9px;">èµ°å‹¢åœ–</td>
                        <td colspan="${g_max}" style="padding:0 !important; text-align:left; vertical-align:top;">
                            <div class="chart-container-wrapper">
                                <div class="chart-legend">
                                    <span style="color:#f44336">â” è´ (æœ€å¤š)</span>
                                    <span style="color:#52c41a">â” è¼¸ (æœ€å°‘)</span>
                                </div>
                                ${g_focusPos.map(p => `<div class="chart-v-highlight" style="left: calc(100% * ${p} / ${g_max});"></div>`).join('')}
                                ${generateTrendChart(winData, failData, winT5, failBottom5)}
                            </div>
                        </td>
                      </tr>`;
        }
        document.getElementById('mBodyMonitor').innerHTML = bHtml;
    }

    function renderSoldierMode() {
        if (!g_history || g_history.length === 0) return;
        let bHtml = ""; let displayList = g_history.slice(-g_nLimit);
        displayList.forEach((item, revIdx) => {
            let realIdx = g_history.length - displayList.length + revIdx, isTestLine = g_backtestIdx === realIdx, isIgnored = g_backtestIdx !== -1 && realIdx > g_backtestIdx;
            bHtml += `<tr class="row-soldier ${isTestLine ? 'backtest-line' : ''} ${isIgnored ? 'ignored-row' : ''}">
                        <td class="sticky-col" onclick="setBacktest(${realIdx})">${item.sn}${isTestLine ? 'ğŸ“Œ' : ''}</td>
                        ${item.order.map((n, pIdx) => `
                            <td class="${item.balls.includes(n) ? 'soldier-win' : ''} ${g_activePaths.has(parseInt(n))?'path-active':''}" 
                                onclick="toggleBallPath(parseInt(${n}))" data-ball="${n}">${n}</td>`).join('')}
                      </tr>`;
        });
        let displayOrder = g_backtestIdx === -1 ? g_curOrder : g_history[g_backtestIdx].order;
        bHtml += `<tr class="ready-line">
                    <td class="sticky-col" onclick="setBacktest(-1)">æ¨æ¼”é»${g_backtestIdx===-1?'':'ğŸ”„'}</td>
                    ${displayOrder.map((n, idx) => `<td class="${g_activePaths.has(parseInt(n))?'path-active':''}" onclick="toggleBallPath(parseInt(${n}))" data-ball="${n}">${n}</td>`).join('')}
                  </tr>`;
        document.getElementById('mBodySoldier').innerHTML = bHtml;
        setTimeout(drawPaths, 80);
    }

    function toggleBallPath(ballNum) {
        if (g_activePaths.has(ballNum)) g_activePaths.delete(ballNum);
        else {
            const colors = ['#007bff', '#e91e63', '#28a745', '#ff9800', '#9c27b0', '#795548', '#00bcd4', '#673ab7'];
            g_activePaths.set(ballNum, colors[g_activePaths.size % colors.length]);
        }
        renderSoldierMode(); renderHeader();
    }

    function drawPaths() {
        const svg = document.getElementById('pathCanvas');
        if (g_mode !== 'soldier' || !g_history || g_history.length === 0) { svg.innerHTML = ''; svg.classList.add('hidden'); return; }
        svg.classList.remove('hidden');
        const table = document.getElementById('matrixTable');
        svg.setAttribute('width', table.scrollWidth); svg.setAttribute('height', table.scrollHeight); svg.innerHTML = '';
        const scrollArea = document.getElementById('scrollArea'), sRect = scrollArea.getBoundingClientRect();
        
        g_activePaths.forEach((color, ballNum) => {
            const dots = Array.from(document.querySelectorAll(`#mBodySoldier [data-ball="${ballNum}"]`)).filter(el => !el.parentElement.classList.contains('ignored-row'));
            if (dots.length < 2) return;
            dots.sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top);
            let d = "";
            dots.forEach((dot, i) => {
                const r = dot.getBoundingClientRect();
                const x = r.left - sRect.left + scrollArea.scrollLeft + r.width/2;
                const y = r.top - sRect.top + scrollArea.scrollTop + r.height/2;
                d += (i===0?"M":"L") + x + "," + y;
                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                c.setAttribute("cx", x); c.setAttribute("cy", y); c.setAttribute("r", "3.5"); c.setAttribute("fill", color); svg.appendChild(c);
            });
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            p.setAttribute("d", d); p.setAttribute("stroke", color); p.setAttribute("stroke-width", "2.5"); p.setAttribute("fill", "none"); p.setAttribute("stroke-opacity", "0.7"); svg.appendChild(p);
        });
    }

    function generateTrendChart(winData, failData, winTops, failBottoms) {
        if (!winData || winData.length === 0) return '';
        const w = 1000, h = 130; 
        const maxVal = Math.max(...winData, ...failData, 1), minVal = Math.min(...winData, ...failData);
        const range = (maxVal - minVal) || 1;
        const getY = (v) => h - 30 - ((v - minVal) / range) * (h - 60);
        const getX = (i) => (i + 0.5) * (w / g_max);
        let svg = `<svg width="100%" height="100%" viewBox="0 0 ${w} ${h}" preserveAspectRatio="none" style="display:block;">`;
        let winP = `M ${getX(0)} ${getY(winData[0])}`;
        for(let i=1; i<g_max; i++) winP += ` L ${getX(i)} ${getY(winData[i])}`;
        svg += `<path d="${winP}" fill="none" stroke="#f44336" stroke-width="2" />`;
        let failP = `M ${getX(0)} ${getY(failData[0])}`;
        for(let i=1; i<g_max; i++) failP += ` L ${getX(i)} ${getY(failData[i])}`;
        svg += `<path d="${failP}" fill="none" stroke="#52c41a" stroke-width="2" />`;
        for(let i=0; i<g_max; i++) {
            const x = getX(i), yW = getY(winData[i]), yF = getY(failData[i]);
            svg += `<circle cx="${x}" cy="${yW}" r="3" fill="#f44336" />`;
            svg += `<circle cx="${x}" cy="${yF}" r="3" fill="#52c41a" />`;
            if(winTops.includes(i)) svg += `<text x="${x}" y="${yW-10}" font-size="20" text-anchor="middle" fill="#f44336" font-weight="bold" transform="scale(0.5)" transform-origin="${x} ${yW-10}">${winData[i]}</text>`;
            if(failBottoms.includes(i)) {
                const offset = (yF > yW - 20) ? 18 : -10;
                svg += `<text x="${x}" y="${yF+offset}" font-size="20" text-anchor="middle" fill="#52c41a" font-weight="bold" transform="scale(0.5)" transform-origin="${x} ${yF+offset}">${failData[i]}</text>`;
            }
        }
        svg += `</svg>`; return svg;
    }

    // --- åˆ†æå ±è¡¨é‚è¼¯ ---
    function handleAddReport() {
        if (!g_history || g_history.length === 0 || g_activePaths.size === 0) return;
        
        // æ¨æ¼”é»ç‚ºç¬¬ 0 æœŸ
        const readyIdx = g_backtestIdx === -1 ? g_history.length : g_backtestIdx + 1;
        let selectedData = [];
        
        g_activePaths.forEach((color, ballNum) => {
            // æ‰¾å‡ºè©²è™Ÿç¢¼åœ¨å£«å…µåœ–å¯è¦–ç¯„åœå…§çš„æœ€å¾Œä¸€å€‹è½é»
            const rows = Array.from(document.querySelectorAll(`#mBodySoldier [data-ball="${ballNum}"]`))
                             .filter(el => !el.parentElement.classList.contains('ignored-row'));
            if (rows.length > 0) {
                const lastEl = rows[rows.length - 1];
                const tr = lastEl.closest('tr');
                const sn = tr.querySelector('td').innerText.replace('ğŸ“Œ', '').trim();
                const histIdx = g_history.findIndex(h => h.sn === sn);
                const pos = Array.from(tr.children).indexOf(lastEl) - 1;
                if (histIdx !== -1) {
                    selectedData.push({
                        ball: ballNum,
                        pos: pos,
                        dist: readyIdx - histIdx - 1, 
                        color: color,
                        histIdx: histIdx
                    });
                }
            }
        });

        if (selectedData.length === 0) return;

        // è¨ˆç®—ç›¸å°è·é›¢ (Cross-Distance)
        let crossDistances = [];
        for (let i = 0; i < selectedData.length; i++) {
            for (let j = i + 1; j < selectedData.length; j++) {
                crossDistances.push({
                    a: selectedData[i].ball,
                    b: selectedData[j].ball,
                    diff: Math.abs(selectedData[i].histIdx - selectedData[j].histIdx)
                });
            }
        }

        const entry = {
            id: Date.now(),
            features: selectedData,
            crossDistances: crossDistances,
            timestamp: new Date().toLocaleTimeString()
        };

        g_analysisEntries.push(entry);
        renderReportTable();
        toggleReport(true);
    }

    function renderReportTable() {
        const area = document.getElementById('entriesArea');
        const empty = document.getElementById('reportEmpty');
        if (g_analysisEntries.length === 0) { area.innerHTML = ""; empty.classList.remove('hidden'); return; }
        empty.classList.add('hidden');

        area.innerHTML = g_analysisEntries.map((entry, idx) => {
            const matches = findMatchesInHistory(entry);
            const ballStats = {};
            matches.forEach(m => m.balls.forEach(b => ballStats[b] = (ballStats[b] || 0) + 1));
            const topStats = Object.entries(ballStats).sort((a,b) => b[1] - a[1]).slice(0, 10);

            return `
            <div class="report-entry-card">
                <div style="display:flex; justify-content:space-between; border-bottom:1px solid #eee; padding-bottom:5px; margin-bottom:10px;">
                    <strong>ç‰¹å¾µç¾¤çµ„ #${idx + 1} <small style="color:#999; font-weight:normal;">(${entry.timestamp})</small></strong>
                    <button onclick="deleteEntry(${entry.id})" style="color:red; border:none; background:none; cursor:pointer; font-weight:bold;">åˆªé™¤æ­¤ç­†</button>
                </div>
                <div style="margin-bottom:10px;">
                    ${entry.features.map(f => `<span class="tag" style="background:${f.color}">#${f.ball} (P${f.pos+1}, è·0æœŸ:${f.dist}æœŸ)</span>`).join('')}
                    ${entry.crossDistances.map(d => `<span style="font-size:9px; color:#666; margin-right:8px;">[#${d.a} å° #${d.b} è·:${d.diff}]</span>`).join('')}
                </div>
                <div style="font-size:11px; margin-bottom:5px;">ç¬¦åˆæ­·å²ç‰¹å¾µï¼š<b>${matches.length}</b> æœŸ</div>
                <div style="display:flex; gap:5px; flex-wrap:wrap;">
                    ${topStats.map(([b, count]) => `
                        <div style="background:#e8eaf6; padding:4px 8px; border-radius:4px; border:1px solid #c5cae9; text-align:center; min-width:35px;">
                            <b style="color:#3f51b5">${b<10?'0'+b:b}</b><br><small style="color:#777">${count}æ¬¡</small>
                        </div>
                    `).join('')}
                </div>
            </div>`;
        }).reverse().join('');
    }

    function findMatchesInHistory(entry) {
        let results = [];
        const maxOffset = Math.max(...entry.features.map(f => f.dist));
        const limit = g_backtestIdx === -1 ? g_history.length : g_backtestIdx + 1;
        for (let i = maxOffset; i < limit; i++) {
            let isMatch = true;
            for (let f of entry.features) {
                const checkIdx = i - f.dist;
                if (checkIdx < 0 || g_history[checkIdx].order[f.pos] !== f.ball) { isMatch = false; break; }
            }
            if (isMatch) results.push({ sn: g_history[i].sn, balls: g_history[i].balls });
        }
        return results;
    }

    function deleteEntry(id) {
        g_analysisEntries = g_analysisEntries.filter(e => e.id !== id);
        renderReportTable();
    }

    function toggleReport(s) { document.getElementById('reportModal').style.display = s ? 'flex' : 'none'; }
    function setBacktest(idx) { g_backtestIdx = (g_backtestIdx === idx) ? -1 : idx; updateMatrix(); renderHeader(); if(g_mode === 'monitor') renderMonitorMode(); else renderSoldierMode(); }
    function switchMode(mode) { 
        g_mode = mode; document.getElementById('drawToolbar').classList.toggle('hidden', mode !== 'soldier');
        document.getElementById('mBodyMonitor').classList.toggle('hidden', mode !== 'monitor');
        document.getElementById('mBodySoldier').classList.toggle('hidden', mode !== 'soldier');
        const svg = document.getElementById('pathCanvas');
        if(mode === 'soldier') svg.classList.remove('hidden'); else { svg.classList.add('hidden'); svg.innerHTML = ''; }
        document.getElementById('btnMonitor').classList.toggle('active', mode === 'monitor');
        document.getElementById('btnSoldier').classList.toggle('active', mode === 'soldier');
        renderHeader(); if(mode === 'monitor') renderMonitorMode(); else renderSoldierMode();
    }

    function getRowTop5(r) { return r.map((v,i)=>({v,i})).sort((a,b)=>b.v-a.v).slice(0,5).map(x=>x.i); }
    function getRowBottom5(r) { return r.map((v,i)=>({v,i})).sort((a,b)=>a.v-b.v).slice(0,5).map(x=>x.i); }
    function getRowRanks(r) { let s = [...r].sort((a,b)=>b-a); return r.map(v=>s.indexOf(v)+1); }
    function getRowRanksAsc(r) { let s = [...r].sort((a,b)=>a-b); return r.map(v=>s.indexOf(v)+1); }
    window.onresize = () => { if (g_history && g_history.length > 0) { drawPaths(); if (g_mode === 'monitor') renderMonitorMode(); } };
</script>

</body>
</html>
